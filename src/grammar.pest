// Grammar for the scripting language

WHITESPACE = _{ " " | "\t" }

program = { SOI ~ "\n"* ~ (item ~ "\n"+)* ~ item? ~ "\n"* ~ EOI }

item = {
    comment
    | function_def
    | function_def_or_call  // Must come before assignment and command
    | assignment
    | command
}

comment = { "#" ~ (!"\n" ~ ANY)* }

// Function definition or call: name() [optional command]
// If there's a space and command text after (), it's a definition
// If there's nothing or just newline/EOF after (), it's a call
function_def_or_call = {
    function_name ~ "(" ~ ")" ~ ((" " | "\t")+ ~ command_text)?
}

// Full function definition: function name() { ... }
function_def = {
    "function" ~ (" " | "\t")+ ~ function_name ~ "(" ~ ")" ~ "{" ~ "\n"* ~ (item ~ "\n"+)* ~ item? ~ "\n"* ~ "}"
}

// Function name supports colon notation for nested commands (e.g., docker:shell)
function_name = @{ identifier ~ (":" ~ identifier)* }

// Assignment: name = value
assignment = {
    identifier ~ "=" ~ expression
}

// Shell command: any line that doesn't match other patterns (but not braces or keywords)
command = {
    !(("function" ~ (" " | "\t")) | "{" | "}") ~
    !(function_name ~ (" " | "\t")* ~ "(" ~ ")") ~
    command_text
}

command_text = @{ (!"\n" ~ ANY)+ }

// Expressions
expression = {
    string
    | number
    | identifier
}

string = @{
    "\"" ~ string_inner ~ "\""
    | "'" ~ string_inner_single ~ "'"
}

string_inner = @{ (!("\"" | "\\") ~ ANY | "\\" ~ ANY)* }
string_inner_single = @{ (!("'" | "\\") ~ ANY | "\\" ~ ANY)* }

number = @{ ASCII_DIGIT+ }

identifier = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }
